name: Guest List Clean Terraform (Deploy)

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      action:
        description: What to run
        type: choice
        required: true
        default: plan
        options: [plan, apply, destroy]
      environment:
        description: Environment / student
        type: choice
        required: true
        default: dev
        options:
          - dev
          - staging
          - main
          - sivan
          - dvir
          - sahar
          - gili

env:
  TF_VERSION: 1.9.8
  TF_CLI_ARGS: -no-color
  AWS_REGION: us-east-1

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.setvars.outputs.environment }}
      namespace: ${{ steps.setvars.outputs.namespace }}
      tf_state_bucket: ${{ steps.setvars.outputs.tf_state_bucket }}
      tf_state_key: ${{ steps.setvars.outputs.tf_state_key }}
      image_repo: ${{ steps.setvars.outputs.image_repo }}
      image_tag_prefix: ${{ steps.setvars.outputs.image_tag_prefix }}
    steps:
      - name: Decide environment/namespace/state layout
        id: setvars
        shell: bash
        run: |
          set -euo pipefail

          # 1) ENV resolution
          if [[ "${GITHUB_EVENT_NAME}" == "push" && "${GITHUB_REF_NAME}" == "main" ]]; then
            ENVIRONMENT="main"
          else
            # From manual picker
            ENVIRONMENT="${{ github.event.inputs.environment || '' }}"
            if [[ -z "${ENVIRONMENT}" ]]; then ENVIRONMENT="dev"; fi
          fi

          NAMESPACE="guestlist"

          # 2) State bucket/key: students use "-feature" suffix
          case "${ENVIRONMENT}" in
            sivan|dvir|sahar|gili)
              TF_STATE_BUCKET="guestlist-tfstate-${ENVIRONMENT}-feature"
              ;;
            *)
              TF_STATE_BUCKET="guestlist-tfstate-${ENVIRONMENT}"
              ;;
          esac
          TF_STATE_KEY="envs/${ENVIRONMENT}/terraform.tfstate"

          # 3) Image repo + tag prefix (students: prefix for latest feature tag; envs: fixed tags)
          IMAGE_REPO="giligalili/guestlistapi"
          case "${ENVIRONMENT}" in
            sivan|dvir|sahar|gili)
              IMAGE_TAG_PREFIX="${ENVIRONMENT}-feature-"
              ;;
            dev)
              IMAGE_TAG_PREFIX="dev"
              ;;
            staging)
              IMAGE_TAG_PREFIX="staging"
              ;;
            main)
              IMAGE_TAG_PREFIX="latest"
              ;;
            *)
              IMAGE_TAG_PREFIX="dev"
              ;;
          esac

          {
            echo "environment=${ENVIRONMENT}"
            echo "namespace=${NAMESPACE}"
            echo "tf_state_bucket=${TF_STATE_BUCKET}"
            echo "tf_state_key=${TF_STATE_KEY}"
            echo "image_repo=${IMAGE_REPO}"
            echo "image_tag_prefix=${IMAGE_TAG_PREFIX}"
          } >> "$GITHUB_OUTPUT"

      - name: Show resolved values
        run: |
          echo "ENVIRONMENT:      ${{ steps.setvars.outputs.environment }}"
          echo "NAMESPACE:        ${{ steps.setvars.outputs.namespace }}"
          echo "TF_STATE_BUCKET:  ${{ steps.setvars.outputs.tf_state_bucket }}"
          echo "TF_STATE_KEY:     ${{ steps.setvars.outputs.tf_state_key }}"
          echo "IMAGE_REPO:       ${{ steps.setvars.outputs.image_repo }}"
          echo "IMAGE_TAG_PREFIX: ${{ steps.setvars.outputs.image_tag_prefix }}"

  configure-environment:
    runs-on: ubuntu-latest
    environment: ${{ needs.determine-environment.outputs.environment }}
    needs: determine-environment
    env:
      ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
      TF_STATE_BUCKET: ${{ needs.determine-environment.outputs.tf_state_bucket }}
    steps:
      - name: Check AWS secrets are present
        run: |
          test -n "${{ secrets.AWS_ACCESS_KEY_ID }}" || { echo "::error::AWS_ACCESS_KEY_ID is missing"; exit 1; }
          test -n "${{ secrets.AWS_SECRET_ACCESS_KEY }}" || { echo "::error::AWS_SECRET_ACCESS_KEY is missing"; exit 1; }

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Ensure S3 state bucket exists (idempotent)
        shell: bash
        run: |
          set -euo pipefail
          B="${TF_STATE_BUCKET}"
          R="${AWS_REGION}"

          if aws s3api head-bucket --bucket "$B" 2>/dev/null; then
            echo "Bucket $B exists."
          else
            if [[ "$R" == "us-east-1" ]]; then
              aws s3api create-bucket --bucket "$B"
            else
              aws s3api create-bucket --bucket "$B" --create-bucket-configuration LocationConstraint="$R"
            fi
            aws s3api put-bucket-versioning --bucket "$B" --versioning-configuration Status=Enabled
            aws s3api put-bucket-encryption --bucket "$B" --server-side-encryption-configuration '{
              "Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'
            aws s3api put-public-access-block --bucket "$B" --public-access-block-configuration \
              BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true
          fi

      - name: Ensure DynamoDB lock table exists (idempotent)
        shell: bash
        run: |
          set -euo pipefail
          T="terraform-locks"
          if aws dynamodb describe-table --table-name "$T" >/dev/null 2>&1; then
            echo "DynamoDB table $T exists."
          else
            aws dynamodb create-table \
              --table-name "$T" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST
            aws dynamodb wait table-exists --table-name "$T"
          fi

  terraform:
    runs-on: ubuntu-latest
    needs: [determine-environment, configure-environment]
    environment: ${{ needs.determine-environment.outputs.environment }}
    env:
      ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
      NAMESPACE: ${{ needs.determine-environment.outputs.namespace }}
      TF_STATE_BUCKET: ${{ needs.determine-environment.outputs.tf_state_bucket }}
      TF_STATE_KEY: ${{ needs.determine-environment.outputs.tf_state_key }}
      IMAGE_REPO: ${{ needs.determine-environment.outputs.image_repo }}
      IMAGE_TAG_PREFIX: ${{ needs.determine-environment.outputs.image_tag_prefix }}
      TF_VAR_state_bucket_name: ${{ needs.determine-environment.outputs.tf_state_bucket }}
      TF_VAR_cluster_role_name: guestlist-cluster-cluster-role
      TF_VAR_node_group_role_name: guestlist-cluster-node-group-role
    steps:
      - uses: actions/checkout@v4

      - name: Check AWS secrets are present
        run: |
          test -n "${{ secrets.AWS_ACCESS_KEY_ID }}" || { echo "::error::AWS_ACCESS_KEY_ID is missing"; exit 1; }
          test -n "${{ secrets.AWS_SECRET_ACCESS_KEY }}" || { echo "::error::AWS_SECRET_ACCESS_KEY is missing"; exit 1; }

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Resolve image tag (and print selection)
        id: imagetag
        shell: bash
        run: |
          set -euo pipefail
          repo="${IMAGE_REPO}"
          prefix="${IMAGE_TAG_PREFIX}"
          tag=""
          case "${ENVIRONMENT}" in
            sivan|dvir|sahar|gili)
              # Latest tag that starts with "<student>-feature-"
              tag="$(curl -fsSL "https://hub.docker.com/v2/repositories/${repo}/tags?page_size=100" \
                | jq -r '.results[] | select(.name | startswith("'"${prefix}"'")) | .name' | head -n1)"
              ;;
            dev|staging|main)
              tag="${prefix}"
              ;;
            *)
              tag="dev"
              ;;
          esac

          if [[ -z "${tag}" ]]; then
            echo "Failed to resolve image tag for ${ENVIRONMENT}" >&2
            exit 1
          fi

          echo "image_tag=${tag}" >> "$GITHUB_OUTPUT"
          echo "Using image: ${repo}:${tag}"
          echo "Docker pull hint: docker pull ${repo}:${tag}"

      - name: Terraform Init (remote state)
        shell: bash
        run: |
          set -euo pipefail
          terraform init -input=false -reconfigure \
            -backend-config="bucket=${TF_STATE_BUCKET}" \
            -backend-config="key=${TF_STATE_KEY}" \
            -backend-config="region=${AWS_REGION}" \
            -backend-config="dynamodb_table=terraform-locks"

      - name: Terraform Plan
        if: |
          (github.event_name == 'workflow_dispatch' && inputs.action == 'plan') ||
          (github.event_name == 'push' && github.ref == 'refs/heads/main')
        shell: bash
        run: |
          set -euo pipefail
          terraform plan -input=false \
            -var="environment=${ENVIRONMENT}" \
            -var="aws_region=${AWS_REGION}" \
            -var="namespace=${NAMESPACE}" \
            -var="image_tag=${{ steps.imagetag.outputs.image_tag }}" \
            -var="aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -var="aws_secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            -out=tfplan-${ENVIRONMENT}

      - name: Terraform Apply
        if: |
          (github.event_name == 'workflow_dispatch' && inputs.action == 'apply') ||
          (github.event_name == 'push' && github.ref == 'refs/heads/main')
        shell: bash
        run: |
          set -euo pipefail
          # If a plan exists from the previous step, use it; otherwise apply directly (push on main path).
          if [[ -f "tfplan-${ENVIRONMENT}" ]]; then
            terraform apply -input=false -auto-approve "tfplan-${ENVIRONMENT}"
          else
            terraform apply -input=false -auto-approve \
              -var="environment=${ENVIRONMENT}" \
              -var="aws_region=${AWS_REGION}" \
              -var="namespace=${NAMESPACE}" \
              -var="image_tag=${{ steps.imagetag.outputs.image_tag }}" \
              -var="aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}" \
              -var="aws_secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}"
          fi

      - name: Show LB URL & health check (port 9999, wait)
        if: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply') || (github.event_name == 'push' && github.ref == 'refs/heads/main') }}
        shell: bash
        run: |
          set -euo pipefail

          # Try to read IP first; if empty, use hostname
          LB="$(terraform output -raw load_balancer_ip 2>/dev/null || true)"
          USE_DNS=0
          if [[ -z "${LB}" ]]; then
            LB="$(terraform output -raw load_balancer_hostname 2>/dev/null || true)"
            USE_DNS=1
          fi

          if [[ -z "${LB}" ]]; then
            echo "Failed to read Terraform output 'load_balancer_ip' or 'load_balancer_hostname'."
            exit 1
          fi

          PORT=9999
          BASE_URL="http://${LB}:${PORT}"
          echo "Load Balancer target: ${BASE_URL}"

          # If hostname, wait for DNS to resolve
          if [[ "${USE_DNS}" -eq 1 ]]; then
            echo "Waiting for DNS to resolve for ${LB}..."
            for i in {1..120}; do
              if getent hosts "${LB}" >/dev/null 2>&1; then
                echo "DNS resolved on attempt #${i}"
                break
              fi
              sleep 5
              [[ $i -eq 120 ]] && { echo "Timed out waiting for DNS (${LB})"; exit 1; }
            done
          fi

          # Health polling: try /healthz then /
          ATTEMPTS=30
          SLEEP=10
          for i in $(seq 1 $ATTEMPTS); do
            CODE="$(curl -sS -m 5 -o /dev/null -w '%{http_code}' "${BASE_URL}/healthz" || echo "000")"
            if [[ "$CODE" -ge 200 && "$CODE" -lt 400 ]]; then
              echo "OK: HTTP $CODE from ${BASE_URL}/healthz"
              exit 0
            fi
            CODE_ROOT="$(curl -sS -m 5 -o /dev/null -w '%{http_code}' "${BASE_URL}/" || echo "000")"
            if [[ "$CODE_ROOT" -ge 200 && "$CODE_ROOT" -lt 400 ]]; then
              echo "OK: HTTP $CODE_ROOT from ${BASE_URL}/"
              exit 0
            fi
            echo "Attempt $i/$ATTEMPTS: healthz=$CODE root=$CODE_ROOT â€” retrying in ${SLEEP}s..."
            sleep $SLEEP
          done

          echo "ERROR: Service not healthy after $((ATTEMPTS*SLEEP))s at ${BASE_URL}"
          exit 1

      - name: Terraform Destroy
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.action == 'destroy' }}
        shell: bash
        run: |
          set -euo pipefail
          terraform destroy -input=false -auto-approve \
            -var="environment=${ENVIRONMENT}" \
            -var="aws_region=${AWS_REGION}" \
            -var="namespace=${NAMESPACE}" \
            -var="image_tag=ignore" \
            -var="aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -var="aws_secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}"